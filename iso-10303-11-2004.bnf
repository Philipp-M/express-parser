;; iso-10303-11:2004

   l   0 ABS = 'abs' .
   l   1 ABSTRACT = 'abstract' .
   l   2 ACOS = 'acos' .
   l   3 AGGREGATE = 'aggregate' .
   l   4 ALIAS = 'alias' .
   l   5 AND = 'and' .
   l   6 ANDOR = 'andor' .
   l   7 ARRAY = 'array' .
   l   8 AS = 'as' .
   l   9 ASIN = 'asin' .
   l  10 ATAN = 'atan' .
   l  11 BAG = 'bag' .
   l  12 BASED_ON = 'based_on' .
   l  13 BEGIN = 'begin' .
   l  14 BINARY = 'binary' .
   l  15 BLENGTH = 'blength' .
   l  16 BOOLEAN = 'boolean' .
   l  17 BY = 'by' .
   l  18 CASE = 'case' .
   l  19 CONSTANT = 'constant' .
   l  20 CONST_E = 'const_e' .
   l  21 COS = 'cos' .
   l  22 DERIVE = 'derive' .
   l  23 DIV = 'div' .
   l  24 ELSE = 'else' .
   l  25 END = 'end' .
   l  26 END_ALIAS = 'end_alias' .
   l  27 END_CASE = 'end_case' .
   l  28 END_CONSTANT = 'end_constant' .
   l  29 END_ENTITY = 'end_entity' .
   l  30 END_FUNCTION = 'end_function' .
   l  31 END_IF = 'end_if' .
   l  32 END_LOCAL = 'end_local' .
   l  33 END_PROCEDURE = 'end_procedure' .
   l  34 END_REPEAT = 'end_repeat' .
   l  35 END_RULE = 'end_rule' .
   l  36 END_SCHEMA = 'end_schema' .
   l  37 END_SUBTYPE_CONSTRAINT = 'end_subtype_constraint' .
   l  38 END_TYPE = 'end_type' .
   l  39 ENTITY = 'entity' .
   l  40 ENUMERATION = 'enumeration' .
   l  41 ESCAPE = 'escape' .
   l  42 EXISTS = 'exists' .
   l  43 EXTENSIBLE = 'extensible' .
   l  44 EXP = 'exp' .
   l  45 FALSE = 'false' .
   l  46 FIXED = 'fixed' .
   l  47 FOR = 'for' .
   l  48 FORMAT = 'format' .
   l  49 FROM = 'from' .
   l  50 FUNCTION = 'function' .
   l  51 GENERIC = 'generic' .
   l  52 GENERIC_ENTITY = 'generic_entity' .
   l  53 HIBOUND = 'hibound' .
   l  54 HIINDEX = 'hiindex' .
   l  55 IF = 'if' .
   l  56 IN = 'in' .
   l  57 INSERT = 'insert' .
   l  58 INTEGER = 'integer' .
   l  59 INVERSE = 'inverse' .
   l  60 LENGTH = 'length' .
   l  61 LIKE = 'like' .
   l  62 LIST = 'list' .
   l  63 LOBOUND = 'lobound' .
   l  64 LOCAL = 'local' .
   l  65 LOG = 'log' .
   l  66 LOG10 = 'log10' .
   l  67 LOG2 = 'log2' .
   l  68 LOGICAL = 'logical' .
   l  69 LOINDEX = 'loindex' .
   l  70 MOD = 'mod' .
   l  71 NOT = 'not' .
   l  72 NUMBER = 'number' .
   l  73 NVL = 'nvl' .
   l  74 ODD = 'odd' .
   l  75 OF = 'of' .
   l  76 ONEOF = 'oneof' .
   l  77 OPTIONAL = 'optional' .
   l  78 OR = 'or' .
   l  79 OTHERWISE = 'otherwise' .
   l  80 PI = 'pi' .
   l  81 PROCEDURE = 'procedure' .
   l  82 QUERY = 'query' .
   l  83 REAL = 'real' .
   l  84 REFERENCE = 'reference' .
   l  85 REMOVE = 'remove' .
   l  86 RENAMED = 'renamed' .
   l  87 REPEAT = 'repeat' .
   l  88 RETURN = 'return' .
   l  89 ROLESOF = 'rolesof' .
   l  90 RULE = 'rule' .
   l  91 SCHEMA = 'schema' .
   l  92 SELECT = 'select' .
   l  93 SELF = 'self' .
   l  94 SET = 'set' .
   l  95 SIN = 'sin' .
   l  96 SIZEOF = 'sizeof' .
   l  97 SKIP = 'skip' .
   l  98 SQRT = 'sqrt' .
   l  99 STRING = 'string' .
   l 100 SUBTYPE = 'subtype' .
   l 101 SUBTYPE_CONSTRAINT = 'subtype_constraint' .
   l 102 SUPERTYPE = 'supertype' .
   l 103 TAN = 'tan' .
   l 104 THEN = 'then' .
   l 105 TO = 'to' .
   l 106 TOTAL_OVER = 'total_over' .
   l 107 TRUE = 'true' .
   l 108 TYPE = 'type' .
   l 109 TYPEOF = 'typeof' .
   l 110 UNIQUE = 'unique' .
   l 111 UNKNOWN = 'unknown' .
   l 112 UNTIL = 'until' .
   l 113 USE = 'use' .
   l 114 USEDIN = 'usedin' .
   l 115 VALUE = 'value' .
   l 116 VALUE_IN = 'value_in' .
   l 117 VALUE_UNIQUE = 'value_unique' .
   l 118 VAR = 'var' .
   l 119 WHERE = 'where' .
   l 120 WHILE = 'while' .
   l 121 WITH = 'with' .
   l 122 XOR = 'xor' .
   l 123 bit = '0' | '1' .
   l 124 digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' .
   l 125 digits = digit { digit } .
   l 126 encoded_character = octet octet octet octet .
   l 127 hex_digit = digit | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' .
   l 128 letter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' .
   l 129 lparen_then_not_lparen_star = '(' { '(' } not_lparen_star { not_lparen_star } .
   l 130 not_lparen_star = not_paren_star | ')' .
   l 131 not_paren_star = letter | digit | not_paren_star_special .
   l 132 not_paren_star_quote_special = '!' | '"' | '#' | '$' | '%' | '&' | '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | '[' | '\' | ']' | '^' | '_' | 'â€˜' | '{' | '|' | '}' | '~' .
   l 133 not_paren_star_special = not_paren_star_quote_special | '''' .
   l 134 not_quote = not_paren_star_quote_special | letter | digit | '(' | ')' | '*' .
   l 135 not_rparen_star = not_paren_star | '(' .
   l 136 octet = hex_digit hex_digit .
   l 137 special = not_paren_star_quote_special | '(' | ')' | '*' | '''' .
   l 138 not_rparen_star_then_rparen = not_rparen_star { not_rparen_star } ')' { ')' } .
p  l 139 binary_literal = '%' bit { bit } .
p  l 140 encoded_string_literal = '"' encoded_character { encoded_character } '"' .
p  l 141 integer_literal = digits .
p  l 142 real_literal = integer_literal | ( digits '.' [ digits ] [ 'e' [ sign ] digits ] ) .
   l 143 simple_id = letter { letter | digit | '_' } .
   l 144 simple_string_literal = \q { ( \q \q ) | not_quote | \s | \x8 | \x9 | \xA | \xB | \xC | \xD } \q .
   l 145 embedded_remark = '(*' [ remark_tag ] { ( not_paren_star { not_paren_star } ) | lparen_then_not_lparen_star | ( '*' { '*' } ) | not_rparen_star_then_rparen | embedded_remark } '*)' .
   l 146 remark = embedded_remark | tail_remark .
   l 147 remark_tag = '"' remark_ref { '.' remark_ref } '"' .
   l 148 remark_ref = attribute_ref | constant_ref | entity_ref | enumeration_ref | function_ref | parameter_ref | procedure_ref | rule_label_ref | rule_ref | schema_ref | subtype_constraint_ref | type_label_ref | type_ref | variable_ref .
   l 149 tail_remark = '--' [ remark_tag ] { \a | \s | \x8 | \x9 | \xA | \xB | \xC | \xD } \n .
//   150 attribute_ref = attribute_id .
//   151 constant_ref = constant_id .
//   152 entity_ref = entity_id .
//   153 enumeration_ref = enumeration_id .
//   154 function_ref = function_id .
//   155 parameter_ref = parameter_id .
//   156 procedure_ref = procedure_id .
//   157 rule_label_ref = rule_label_id .
//   158 rule_ref = rule_id .
//   159 schema_ref = schema_id .
//   160 subtype_constraint_ref = subtype_constraint_id .
//   161 type_label_ref = type_label_id .
//   162 type_ref = type_id .
//   163 variable_ref = variable_id .

     164 abstract_entity_declaration = ABSTRACT .
     165 abstract_supertype = ABSTRACT SUPERTYPE ';' .
     166 abstract_supertype_declaration = ABSTRACT SUPERTYPE [ subtype_constraint ] .
     167 actual_parameter_list = '(' parameter { ',' parameter } ')' .
   l 168 add_like_op = '+' | '-' | OR | XOR .
     169 aggregate_initializer = '[' [ element { ',' element } ] ']' .
     170 aggregate_source = simple_expression .
     171 aggregate_type = AGGREGATE [ ':' type_label ] OF parameter_type .
     172 aggregation_types = array_type | bag_type | list_type | set_type .
     173 algorithm_head = { declaration } [ constant_decl ] [ local_decl ] .
     174 alias_stmt = ALIAS variable_id FOR general_ref { qualifier } ';' stmt { stmt } END_ALIAS ';' .
     175 array_type = ARRAY bound_spec OF [ OPTIONAL ] [ UNIQUE ] instantiable_type .
     176 assignment_stmt = general_ref { qualifier } ':=' expression ';' .
     177 attribute_decl = attribute_id | redeclared_attribute .
     178 attribute_id = simple_id .
     179 attribute_qualifier = '.' attribute_ref .
     180 bag_type = BAG [ bound_spec ] OF instantiable_type .
     181 binary_type = BINARY [ width_spec ] .
     182 boolean_type = BOOLEAN .
     183 bound_1 = numeric_expression .
     184 bound_2 = numeric_expression .
     185 bound_spec = '[' bound_1 ':' bound_2 ']' .
p    186 built_in_constant = CONST_E | PI | SELF | '?' .
     187 built_in_function = ABS | ACOS | ASIN | ATAN | BLENGTH | COS | EXISTS | EXP | FORMAT | HIBOUND | HIINDEX | LENGTH | LOBOUND | LOINDEX | LOG | LOG2 | LOG10 | NVL | ODD | ROLESOF | SIN | SIZEOF | SQRT | TAN | TYPEOF | USEDIN | VALUE | VALUE_IN | VALUE_UNIQUE .
     188 built_in_procedure = INSERT | REMOVE .
     189 case_action = case_label { ',' case_label } ':' stmt .
     190 case_label = expression .
     191 case_stmt = CASE selector OF { case_action } [ OTHERWISE ':' stmt ] END_CASE ';' .
     192 compound_stmt = BEGIN stmt { stmt } END ';' .
     193 concrete_types = aggregation_types | simple_types | type_ref .
     194 constant_body = constant_id ':' instantiable_type ':=' expression ';' .
     195 constant_decl = CONSTANT constant_body { constant_body } END_CONSTANT ';' .
p    196 constant_factor = built_in_constant | constant_ref .
     197 constant_id = simple_id .
     198 constructed_types = enumeration_type | select_type .
     199 declaration = entity_decl | function_decl | procedure_decl | subtype_constraint_decl | type_decl .
     200 derived_attr = attribute_decl ':' parameter_type ':=' expression ';' .
     201 derive_clause = DERIVE derived_attr { derived_attr } .
     202 domain_rule = [ rule_label_id ':' ] expression .
     203 element = expression [ ':' repetition ] .
     204 entity_body = { explicit_attr } [ derive_clause ] [ inverse_clause ] [ unique_clause ] [ where_clause ] .
     205 entity_constructor = entity_ref '(' [ expression { ',' expression } ] ')' .
     206 entity_decl = entity_head entity_body END_ENTITY ';' .
     207 entity_head = ENTITY entity_id subsuper ';' .
     208 entity_id = simple_id .
     209 enumeration_extension = BASED_ON type_ref [ WITH enumeration_items ] .
     210 enumeration_id = simple_id .
     211 enumeration_items = '(' enumeration_id { ',' enumeration_id } ')' .
     212 enumeration_reference = [ type_ref '.' ] enumeration_ref .
     213 enumeration_type = [ EXTENSIBLE ] ENUMERATION [ ( OF enumeration_items ) | enumeration_extension ] .
     214 escape_stmt = ESCAPE ';' .
     215 explicit_attr = attribute_decl { ',' attribute_decl } ':' [ OPTIONAL ] parameter_type ';' .
p    216 expression = simple_expression [ rel_op_extended simple_expression ] .
     217 factor = simple_factor [ '**' simple_factor ] .
     218 formal_parameter = parameter_id { ',' parameter_id } ':' parameter_type .
p    219 function_call = ( built_in_function | function_ref ) [ actual_parameter_list ] .
     220 function_decl = function_head algorithm_head stmt { stmt } END_FUNCTION ';' .
     221 function_head = FUNCTION function_id [ '(' formal_parameter { ';' formal_parameter } ')' ] ':' parameter_type ';' .
     222 function_id = simple_id .
     223 generalized_types = aggregate_type | general_aggregation_types | generic_entity_type | generic_type .
     224 general_aggregation_types = general_array_type | general_bag_type | general_list_type | general_set_type .
     225 general_array_type = ARRAY [ bound_spec ] OF [ OPTIONAL ] [ UNIQUE ] parameter_type .
     226 general_bag_type = BAG [ bound_spec ] OF parameter_type .
     227 general_list_type = LIST [ bound_spec ] OF [ UNIQUE ] parameter_type .
     228 general_ref = parameter_ref | variable_ref .
     229 general_set_type = SET [ bound_spec ] OF parameter_type .
     230 generic_entity_type = GENERIC_ENTITY [ ':' type_label ] .
     231 generic_type = GENERIC [ ':' type_label ] .
     232 group_qualifier = '\' entity_ref .
     233 if_stmt = IF logical_expression THEN stmt { stmt } [ ELSE stmt { stmt } ] END_IF ';' .
     234 increment = numeric_expression .
     235 increment_control = variable_id ':=' bound_1 TO bound_2 [ BY increment ] .
     236 index = numeric_expression .
     237 index_1 = index .
     238 index_2 = index .
     239 index_qualifier = '[' index_1 [ ':' index_2 ] ']' .
     240 instantiable_type = concrete_types | entity_ref .
     241 integer_type = INTEGER .
     242 interface_specification = reference_clause | use_clause .
     243 interval = '{' interval_low interval_op interval_item interval_op interval_high '}' .
     244 interval_high = simple_expression .
     245 interval_item = simple_expression .
     246 interval_low = simple_expression .
     247 interval_op = '<' | '<=' .
     248 inverse_attr = attribute_decl ':' [ ( SET | BAG ) [ bound_spec ] OF ] entity_ref FOR [ entity_ref '.' ] attribute_ref ';' .
     249 inverse_clause = INVERSE inverse_attr { inverse_attr } .
     250 list_type = LIST [ bound_spec ] OF [ UNIQUE ] instantiable_type .
     251 literal = binary_literal | logical_literal | real_literal | string_literal .
     252 local_decl = LOCAL local_variable { local_variable } END_LOCAL ';' .
     253 local_variable = variable_id { ',' variable_id } ':' parameter_type [ ':=' expression ] ';' .
     254 logical_expression = expression .
p    255 logical_literal = FALSE | TRUE | UNKNOWN .
     256 logical_type = LOGICAL .
     257 multiplication_like_op = '*' | '/' | DIV | MOD | AND | '||' .
     258 named_types = entity_ref | type_ref .
     259 named_type_or_rename = named_types [ AS ( entity_id | type_id ) ] .
     260 null_stmt = ';' .
     261 number_type = NUMBER .
     262 numeric_expression = simple_expression .
     263 one_of = ONEOF '(' supertype_expression { ',' supertype_expression } ')' .
     264 parameter = expression .
   l 265 parameter_id = simple_id .
     266 parameter_type = generalized_types | named_types | simple_types .
p    267 population = entity_ref .
     268 precision_spec = numeric_expression .
     269 primary = literal | ( qualifiable_factor { qualifier } ) .
     270 procedure_call_stmt = ( built_in_procedure | procedure_ref ) [ actual_parameter_list ] ';' .
     271 procedure_decl = procedure_head algorithm_head { stmt } END_PROCEDURE ';' .
     272 procedure_head = PROCEDURE procedure_id [ '(' [ VAR ] formal_parameter { ';' [ VAR ] formal_parameter } ')' ] ';' .
   l 273 procedure_id = simple_id .
     274 qualifiable_factor = attribute_ref | constant_factor | function_call | general_ref | population .
     275 qualified_attribute = SELF group_qualifier attribute_qualifier .
     276 qualifier = attribute_qualifier | group_qualifier | index_qualifier .
     277 query_expression = QUERY '(' variable_id '<*' aggregate_source '|' logical_expression ')' .
     278 real_type = REAL [ '(' precision_spec ')' ] .
     279 redeclared_attribute = qualified_attribute [ RENAMED attribute_id ] .
     280 referenced_attribute = attribute_ref | qualified_attribute .
     281 reference_clause = REFERENCE FROM schema_ref [ '(' resource_or_rename { ',' resource_or_rename } ')' ] ';' .
p    282 rel_op = '<' | '>' | '<=' | '>=' | '<>' | '=' | ':<>:' | ':=:' .
p    283 rel_op_extended = rel_op | IN | LIKE .
   l 284 rename_id = constant_id | entity_id | function_id | procedure_id | type_id .
     285 repeat_control = [ increment_control ] [ while_control ] [ until_control ] .
     286 repeat_stmt = REPEAT repeat_control ';' stmt { stmt } END_REPEAT ';' .
     287 repetition = numeric_expression .
     288 resource_or_rename = resource_ref [ AS rename_id ] .
     289 resource_ref = constant_ref | entity_ref | function_ref | procedure_ref | type_ref .
     290 return_stmt = RETURN [ '(' expression ')' ] ';' .
     291 rule_decl = rule_head algorithm_head { stmt } where_clause END_RULE ';' .
     292 rule_head = RULE rule_id FOR '(' entity_ref { ',' entity_ref } ')' ';' .
   l 293 rule_id = simple_id .
   l 294 rule_label_id = simple_id .
     295 schema_body = { interface_specification } [ constant_decl ] { declaration | rule_decl } .
     296 schema_decl = SCHEMA schema_id [ schema_version_id ] ';' schema_body END_SCHEMA ';' .
     297 schema_id = simple_id .
     298 schema_version_id = string_literal .
     299 selector = expression .
     300 select_extension = BASED_ON type_ref [ WITH select_list ] .
     301 select_list = '(' named_types { ',' named_types } ')' .
     302 select_type = [ EXTENSIBLE [ GENERIC_ENTITY ] ] SELECT [ select_list | select_extension ] .
     303 set_type = SET [ bound_spec ] OF instantiable_type .
     304 sign = '+' | '-' .
     305 simple_expression = term { add_like_op term } .
     306 simple_factor = aggregate_initializer | entity_constructor | enumeration_reference | interval | query_expression | ( [ unary_op ] ( '(' expression ')' | primary ) ) .
     307 simple_types = binary_type | boolean_type | integer_type | logical_type | number_type | real_type | string_type .
     308 skip_stmt = SKIP ';' .
     309 stmt = alias_stmt | assignment_stmt | case_stmt | compound_stmt | escape_stmt | if_stmt | null_stmt | procedure_call_stmt | repeat_stmt | return_stmt | skip_stmt .
     310 string_literal = simple_string_literal | encoded_string_literal .
     311 string_type = STRING [ width_spec ] .
     312 subsuper = [ supertype_constraint ] [ subtype_declaration ] .
     313 subtype_constraint = OF '(' supertype_expression ')' .
     314 subtype_constraint_body = [ abstract_supertype ] [ total_over ] [ supertype_expression ';' ] .
     315 subtype_constraint_decl = subtype_constraint_head subtype_constraint_body END_SUBTYPE_CONSTRAINT ';' .
     316 subtype_constraint_head = SUBTYPE_CONSTRAINT subtype_constraint_id FOR entity_ref ';' .
   l 317 subtype_constraint_id = simple_id .
     318 subtype_declaration = SUBTYPE OF '(' entity_ref { ',' entity_ref } ')' .
     319 supertype_constraint = abstract_entity_declaration | abstract_supertype_declaration | supertype_rule .
     320 supertype_expression = supertype_factor { ANDOR supertype_factor } .
     321 supertype_factor = supertype_term { AND supertype_term } .
     322 supertype_rule = SUPERTYPE subtype_constraint .
     323 supertype_term = entity_ref | one_of | '(' supertype_expression ')' .
     324 syntax = schema_decl { schema_decl } .
     325 term = factor { multiplication_like_op factor } .
     326 total_over = TOTAL_OVER '(' entity_ref { ',' entity_ref } ')' ';' .
     327 type_decl = TYPE type_id '=' underlying_type ';' [ where_clause ] END_TYPE ';' .
   l 328 type_id = simple_id .
     329 type_label = type_label_id | type_label_ref .
   l 330 type_label_id = simple_id .
     331 unary_op = '+' | '-' | NOT .
     332 underlying_type = concrete_types | constructed_types .
     333 unique_clause = UNIQUE unique_rule ';' { unique_rule ';' } .
     334 unique_rule = [ rule_label_id ':' ] referenced_attribute { ',' referenced_attribute } .
     335 until_control = UNTIL logical_expression .
     336 use_clause = USE FROM schema_ref [ '(' named_type_or_rename { ',' named_type_or_rename } ')' ] ';' .
   l 337 variable_id = simple_id .
     338 where_clause = WHERE domain_rule ';' { domain_rule ';' } .
     339 while_control = WHILE logical_expression .
     340 width = numeric_expression .
     341 width_spec = '(' width ')' [ FIXED ] .
     